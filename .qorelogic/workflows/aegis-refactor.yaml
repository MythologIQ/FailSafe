name: aegis-refactor
version: "1.0.0"
description: KISS Refactor and Simplification Pass - flatten logic, deconstruct bloat
phase: IMPLEMENT (maintenance)
orbit: orbit-specialist
risk_grade: L1

triggers:
  - command: "/aegis-refactor"
  - command: "/refactor"
  - condition: "kiss_violation_detected"
  - condition: "auto_refactor_requested"

inputs:
  target:
    type: string
    required: true
    description: File or directory to refactor
  scope:
    type: enum
    options: ["single-file", "multi-file"]
    default: "single-file"
    description: Scope of refactoring operation

outputs:
  - Refactored source files
  - docs/SYSTEM_STATE.md (updated)
  - docs/META_LEDGER.md (updated)

preconditions:
  - name: target_exists
    check: "{{ target }}"
    expect: "exists"
    on_fail:
      action: abort
      message: "Target not found: {{ target }}"

steps:
  - id: activate_specialist
    name: Identity Activation
    action: activate_orbit
    orbit: orbit-specialist
    mode: "Zero Fluff - Refactor"

  - id: analyze_target
    name: Environment Scan
    action: analyze
    target: "{{ target }}"
    metrics:
      - function_lengths
      - nesting_depths
      - variable_names
      - file_lengths
      - import_chains
    output: analysis_report

  - id: identify_violations
    name: Identify §4 Violations
    action: filter
    from: analysis_report
    conditions:
      - function_lines > 40
      - nesting_depth > 3
      - has_nested_ternary
      - has_generic_variable
      - file_lines > 250
    output: violations

  # === SINGLE FILE MICRO-REFACTOR ===
  - id: micro_refactor
    name: Single-File Micro-Refactor
    condition: "{{ scope }} == 'single-file'"
    steps:
      - id: decompose_functions
        name: Function Decomposition
        action: refactor
        type: split_function
        condition: "function.lines > 40"
        strategy: |
          1. Identify logical sections (validation, transformation, persistence, notification)
          2. Extract each section to named sub-function
          3. Main function becomes orchestrator calling sub-functions
          4. Each sub-function < 40 lines
        example:
          before: |
            function processOrder(order) {
              // validation (15 lines)
              // transformation (20 lines)
              // persistence (15 lines)
              // notification (10 lines)
            }
          after: |
            function processOrder(order) {
              const validated = validateOrder(order);
              const transformed = transformOrder(validated);
              const saved = persistOrder(transformed);
              notifyOrderComplete(saved);
              return saved;
            }

      - id: flatten_nesting
        name: Logic Flattening
        action: refactor
        type: flatten
        condition: "nesting_depth > 3"
        strategy: |
          Replace deep nesting with early returns:
          1. Identify deepest nested condition
          2. Invert condition with early return
          3. Remove one nesting level
          4. Repeat until depth <= 3
        example:
          before: |
            if (id) {
              const user = db.find(id);
              if (user) {
                if (user.active) {
                  if (user.verified) {
                    return user;
                  }
                }
              }
            }
            return null;
          after: |
            if (!id) return null;
            const user = db.find(id);
            if (!user) return null;
            if (!user.active) return null;
            if (!user.verified) return null;
            return user;

      - id: eliminate_ternaries
        name: Nested Ternary Elimination
        action: refactor
        type: eliminate_ternary
        condition: "has_nested_ternary"
        strategy: |
          Extract nested ternary to named function with explicit if/else
        example:
          before: |
            const status = isActive ? isPremium ? 'active-premium' : 'active-basic' : 'inactive';
          after: |
            function getStatus(isActive, isPremium) {
              if (!isActive) return 'inactive';
              return isPremium ? 'active-premium' : 'active-basic';
            }
            const status = getStatus(isActive, isPremium);

      - id: rename_variables
        name: Variable Renaming
        action: refactor
        type: rename
        condition: "has_generic_variable"
        replacements:
          x: "contextual_name based on usage"
          data: "responsePayload | formData | userInput"
          obj: "configOptions | userSettings"
          temp: "intermediateResult | pendingValue"
          item: "orderLineItem | menuEntry"
          result: "validationOutcome | processedOutput"
        strategy: "Analyze usage context to determine appropriate noun/verbNoun name"

      - id: cleanup_artifacts
        name: Cleanup
        action: remove
        patterns:
          - "console\\.log\\(.*\\)"
          - "// TODO(?!:)"
          - "debugger;"
          - "/* eslint-disable */"
        also_remove:
          - "Commented-out code blocks > 3 lines"
          - "Empty catch blocks"
          - "Unused imports"

  # === MULTI-FILE MACRO-REFACTOR ===
  - id: macro_refactor
    name: Multi-File Macro-Refactor
    condition: "{{ scope }} == 'multi-file'"
    steps:
      - id: orphan_detection
        name: Orphan Detection
        action: trace_imports
        entry_points:
          - src/index.ts
          - src/main.tsx
        output: import_graph
        report: |
          | File | Connected | Import Chain |
          |------|-----------|--------------|
          {% for f in files %}
          | {{ f.path }} | {{ '✓' if f.connected else '✗ ORPHAN' }} | {{ f.chain }} |
          {% endfor %}
        on_orphan:
          action: suggest
          message: "Remove orphaned file or wire into build path"

      - id: file_splitting
        name: File Splitting
        action: refactor
        type: split_file
        condition: "file.lines > 250"
        strategy: |
          1. Identify cohesive function groups
          2. Create sibling files for each group
          3. Create index.ts for re-exports
          4. Update imports in consuming files
        example:
          before: |
            src/utils.ts (400 lines)
              - stringHelpers (80 lines)
              - dateHelpers (120 lines)
              - validationHelpers (100 lines)
              - formatters (100 lines)
          after: |
            src/utils/
              - index.ts (re-exports)
              - stringHelpers.ts (80 lines)
              - dateHelpers.ts (120 lines)
              - validationHelpers.ts (100 lines)
              - formatters.ts (100 lines)

      - id: god_object_elimination
        name: God Object Elimination
        action: refactor
        type: split_class
        condition: "class.responsibilities > 1"
        strategy: |
          Apply Single Responsibility Principle:
          1. Identify distinct responsibilities
          2. Create separate class for each
          3. Use composition/injection instead of inheritance
        example:
          before: |
            class UserManager {
              // CRUD operations
              // Authentication
              // Email notifications
            }
          after: |
            class UserRepository { /* CRUD */ }
            class AuthService { /* auth */ }
            class EmailService { /* email */ }

      - id: dependency_audit
        name: Dependency Audit
        action: analyze
        target: package.json
        for_each_dependency:
          checks:
            - is_used: "Verify import exists somewhere"
            - is_necessary: "Can vanilla replace in <10 lines?"
          on_unused:
            action: suggest_remove
          on_unnecessary:
            action: suggest_replace
        output: dependency_report

  - id: verify_compliance
    name: Post-Refactor Compliance Check
    action: validate
    policy: kiss-razor
    target: "{{ all_modified_files }}"
    report: |
      ### §4 Razor Compliance After Refactor

      | File | Lines | Max Function | Max Nesting | Status |
      |------|-------|--------------|-------------|--------|
      {% for f in files %}
      | {{ f.path }} | {{ f.lines }}/250 | {{ f.max_fn }}/40 | {{ f.nesting }}/3 | {{ '✓' if f.compliant else '✗' }} |
      {% endfor %}
    on_violation:
      action: loop_back
      message: "Still non-compliant. Continue refactoring."

  - id: run_tests
    name: Verify Tests Still Pass
    action: execute
    command: "npm test"
    on_fail:
      action: rollback
      message: "Tests broken by refactor. Rolling back."

  - id: update_system_state
    name: Update System State
    action: update_file
    path: docs/SYSTEM_STATE.md
    content: |
      # System State

      **Last Updated**: {{ ISO_8601_NOW }}
      **Updated By**: Specialist (refactor pass)

      ## File Tree
      ```
      {{ current_file_tree }}
      ```

      ## Metrics

      | Metric | Before | After |
      |--------|--------|-------|
      | Total Files | {{ before.file_count }} | {{ after.file_count }} |
      | Total Lines | {{ before.line_count }} | {{ after.line_count }} |
      | Max File Lines | {{ before.max_file }} | {{ after.max_file }} |
      | §4 Violations | {{ before.violations }} | 0 |

  - id: update_ledger
    name: Update Merkle Ledger
    action: append_ledger_entry
    path: docs/META_LEDGER.md
    entry:
      id: "{{ next_entry_id }}"
      timestamp: "{{ ISO_8601_NOW }}"
      phase: "IMPLEMENT (refactor)"
      author: Specialist
      scope: "{{ scope }}"
      changes: "{{ changes_summary }}"
      content_hash: "{{ compute_hash(modified_files) }}"
      previous_hash: "{{ previous_entry_hash }}"
      chain_hash: "{{ compute_chain_hash(content_hash, previous_entry_hash) }}"
      decision: "KISS refactor complete. §4 compliance verified."

  - id: final_report
    name: Generate Refactor Report
    action: output
    format: |
      ## Refactor Complete

      **Scope**: {{ scope }}
      **Target**: {{ target }}
      **Violations Fixed**: {{ violations | length }}
      **Files Modified**: {{ modified_files | length }}

      ### Changes Summary
      | Change Type | Count |
      |-------------|-------|
      | Functions split | {{ split_functions }} |
      | Nesting flattened | {{ flattened_nesting }} |
      | Variables renamed | {{ renamed_vars }} |
      | Files split | {{ split_files }} |
      | Orphans removed | {{ removed_orphans }} |
      | Dependencies removed | {{ removed_deps }} |

      ### Next Action
      The Judge should invoke /aegis-substantiate to verify and seal.

      ---
      *Simplification complete. Awaiting substantiation.*

postconditions:
  - name: no_violations
    check: "All files pass kiss-razor policy"
    expect: "true"

  - name: tests_pass
    check: "npm test exits with 0"
    expect: "true"

error_handling:
  on_test_failure:
    action: rollback
    message: "Refactor broke tests. Reverting changes."

  on_compliance_failure:
    action: continue_refactor
    message: "Still non-compliant. Continuing refinement."
