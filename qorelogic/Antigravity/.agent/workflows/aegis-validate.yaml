name: aegis-validate
version: "1.0.0"
description: Merkle Chain Validator - verify cryptographic integrity of Meta Ledger
phase: ANY
orbit: orbit-judge
risk_grade: L1

triggers:
  - command: "/aegis-validate"
  - command: "/validate"
  - condition: "session_init"
  - condition: "chain_integrity_concern"

inputs: []

outputs:
  - Chain validity report (console output)

preconditions:
  - name: ledger_exists
    check: "docs/META_LEDGER.md"
    expect: "exists"
    on_fail:
      action: abort
      message: "No Meta Ledger found. Run /aegis-bootstrap first."

steps:
  - id: activate_judge
    name: Identity Activation
    action: activate_orbit
    orbit: orbit-judge
    mode: "Validation (read-only)"

  - id: load_ledger
    name: Load Meta Ledger
    action: read_file
    path: docs/META_LEDGER.md
    output: ledger_content

  - id: parse_entries
    name: Parse Ledger Entries
    action: parse
    content: "{{ ledger_content }}"
    pattern: |
      ### Entry #(\d+).*?
      \*\*Timestamp\*\*: (.+)
      \*\*Phase\*\*: (.+)
      .*?
      \*\*Content Hash\*\*:[\s\S]*?= ([a-f0-9]+)
      .*?
      \*\*Previous Hash\*\*: ([a-f0-9]+|GENESIS)
      .*?
      \*\*Chain Hash\*\*:[\s\S]*?= ([a-f0-9]+)
    output: entries

  - id: verify_chain
    name: Verify Hash Chain
    action: compute
    algorithm: |
      expected_previous = "0" * 64  # Genesis
      results = []

      for entry in entries:
        # Calculate expected chain hash
        expected_chain = sha256(entry.content_hash + expected_previous)

        # Compare with recorded
        is_valid = (entry.chain_hash == expected_chain)

        results.append({
          'entry_id': entry.id,
          'timestamp': entry.timestamp,
          'phase': entry.phase,
          'expected_chain': expected_chain,
          'recorded_chain': entry.chain_hash,
          'valid': is_valid
        })

        if not is_valid:
          return {
            'status': 'BROKEN',
            'broken_at': entry.id,
            'results': results
          }

        expected_previous = entry.chain_hash

      return {
        'status': 'VALID',
        'total_entries': len(entries),
        'results': results
      }
    output: chain_verification

  - id: check_referenced_docs
    name: Verify Referenced Documents Exist
    action: check_files
    files:
      - path: docs/CONCEPT.md
        variable: concept_exists
      - path: docs/ARCHITECTURE_PLAN.md
        variable: blueprint_exists
      - path: .agent/staging/AUDIT_REPORT.md
        variable: audit_exists
      - path: docs/SYSTEM_STATE.md
        variable: state_exists

  - id: deep_content_verify
    name: Deep Content Verification (Optional)
    action: conditional
    if: "{{ chain_verification.status }} == 'VALID'"
    then:
      action: compute
      for_each: "{{ entries }}"
      logic: |
        # For recent entries, verify content hash still matches
        if entry.phase == 'BOOTSTRAP':
          concept = read_file('docs/CONCEPT.md')
          arch = read_file('docs/ARCHITECTURE_PLAN.md')
          expected = sha256(concept + arch)
          if expected != entry.content_hash:
            return {'drift': True, 'entry': entry.id}

        elif entry.phase == 'GATE':
          if file_exists('.agent/staging/AUDIT_REPORT.md'):
            report = read_file('.agent/staging/AUDIT_REPORT.md')
            expected = sha256(report)
            # Note: Old audit reports may be overwritten, so drift is expected
      output: content_verification

  - id: generate_report_valid
    name: Generate Valid Chain Report
    condition: "{{ chain_verification.status }} == 'VALID'"
    action: output
    format: |
      # Merkle Chain Validation Report

      **Timestamp**: {{ ISO_8601_NOW }}
      **Auditor**: The QoreLogic Judge

      ---

      ## Chain Status: VALID ✓

      The cryptographic integrity of the Meta Ledger has been verified.

      ### Summary

      | Metric | Value |
      |--------|-------|
      | Total Entries | {{ chain_verification.total_entries }} |
      | Genesis Hash | {{ entries[0].chain_hash[:8] }}... |
      | Latest Hash | {{ entries[-1].chain_hash[:8] }}... |
      | Chain Length | {{ chain_verification.total_entries }} links |

      ### Entry-by-Entry Verification

      | Entry | Phase | Timestamp | Hash Prefix | Status |
      |-------|-------|-----------|-------------|--------|
      {% for r in chain_verification.results %}
      | #{{ r.entry_id }} | {{ r.phase }} | {{ r.timestamp }} | {{ r.recorded_chain[:8] }}... | ✓ |
      {% endfor %}

      ### Chain Visualization

      ```
      GENESIS ─┬─→ #1 ({{ entries[0].phase }})
               │    hash: {{ entries[0].chain_hash[:12] }}...
      {% for e in entries[1:] %}
               │
               ├─→ #{{ e.id }} ({{ e.phase }})
               │    hash: {{ e.chain_hash[:12] }}...
               │    prev: {{ e.previous_hash[:12] }}...
      {% endfor %}
      ```

      ### Referenced Document Status

      | Document | Exists |
      |----------|--------|
      | docs/CONCEPT.md | {{ '✓' if concept_exists else '✗' }} |
      | docs/ARCHITECTURE_PLAN.md | {{ '✓' if blueprint_exists else '✗' }} |
      | .agent/staging/AUDIT_REPORT.md | {{ '✓' if audit_exists else '✗' }} |
      | docs/SYSTEM_STATE.md | {{ '✓' if state_exists else '✗' }} |

      ---

      *Chain integrity confirmed. All decisions are traceable.*

  - id: generate_report_broken
    name: Generate Broken Chain Report
    condition: "{{ chain_verification.status }} == 'BROKEN'"
    action: output
    format: |
      # Merkle Chain Validation Report

      **Timestamp**: {{ ISO_8601_NOW }}
      **Auditor**: The QoreLogic Judge

      ---

      ## Chain Status: BROKEN ✗

      **CRITICAL**: The cryptographic integrity has been compromised.

      ### Break Location

      | Attribute | Value |
      |-----------|-------|
      | Broken At | Entry #{{ chain_verification.broken_at }} |
      | Last Valid | Entry #{{ chain_verification.broken_at - 1 }} |
      | Break Type | HASH_MISMATCH |

      ### Discrepancy Details

      **Entry #{{ chain_verification.broken_at }}**:
      {% set broken = chain_verification.results | selectattr('entry_id', 'eq', chain_verification.broken_at) | first %}
      - Recorded Chain Hash: `{{ broken.recorded_chain }}`
      - Expected Chain Hash: `{{ broken.expected_chain }}`

      ### Possible Causes

      1. **Manual Edit**: The ledger file was modified outside A.E.G.I.S.
      2. **Corruption**: File system corruption or incomplete write
      3. **Tampering**: Deliberate modification of decision history
      4. **Sync Conflict**: Multiple sessions modified concurrently

      ### Required Action

      **DATASET LOCKED**

      No implementation may proceed until integrity is restored.

      **Options**:
      1. **Restore from Backup**: If clean backup exists, restore docs/META_LEDGER.md
      2. **Rebuild Chain**: Re-run phases from broken point with new hashes
      3. **Manual Audit**: Investigate and document resolution

      ### Entry-by-Entry Verification

      | Entry | Phase | Hash Prefix | Status |
      |-------|-------|-------------|--------|
      {% for r in chain_verification.results %}
      | #{{ r.entry_id }} | {{ r.phase }} | {{ r.recorded_chain[:8] }}... | {{ '✓' if r.valid else '✗ BREAK' }} |
      {% endfor %}

      ---

      *Chain integrity compromised. Manual intervention required.*

  - id: lock_dataset_if_broken
    name: Lock Dataset If Broken
    condition: "{{ chain_verification.status }} == 'BROKEN'"
    action: set_flag
    flag: dataset_locked
    value: true
    reason: "Merkle chain integrity failure"

postconditions: []

error_handling:
  on_parse_error:
    action: report
    message: "Could not parse ledger. File may be corrupted."

  on_read_error:
    action: abort
    message: "Could not read Meta Ledger."
